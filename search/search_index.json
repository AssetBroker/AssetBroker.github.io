{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AssetBroker","text":"<p>Modular, Plugin based C2 server</p> Flint ** @ @ @@ * * @ @ @@ * * @ @ @@ * * @ @ @@ * * @ @ @@ * * @ @ @@ * * @ @ @@ * * @ @ @@ * * @ @ @@ ****  <p> Code Coverage</p>"},{"location":"#types","title":"Types","text":"Name Description Colors This class defined a good set of ANSI colors. CxxABI Wrapper around usefull C++/C low level functions Got demangle, backtrace... !!! tip This class is only made of static functions. It does not contain constructor, nor destructor This means that you don't need to instanciate it, and only use it as if it was a namespace. Exception Wrapper arround default std::exception Store the the exception description as std::string, and store some usefull localisation informations: Filename, Line, and Function Name. This is automated using the throw_exception preprocessor directive. !!! tip Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception. NotImplementedError Sample Flint::Exceptions::Exception to register NotImplemented features !!! tip You should use that Exception as a C++ Implementation of the Rust todo!() macro. !!! example <code>cpp throw_exception(Flint::Exceptions::NotImplementedError, \"This function haven't been implemented as of today !\");</code> Inspection Base class to implement simplet self-reflexion in C++  <code>T</code> :    Child class itself !!! tip When creating a child class, define as follow : <code>cpp class ChildClass: public Inspection&lt;ChildClass&gt;</code> This will extand the ChildClass with the self-reflexion class Inspection !!! warning If the class you want to extand as a reflected class will be a parent class (I.E. You will create childs of this \"target\" class), you might want to mark inheritence as virtual. This is needed if your child class also need to be reflected. This way, there is no confilict between the parent reflexion, and the child reflexion."},{"location":"#macros","title":"Macros","text":"Name Description FUNCTION ** @ @ @@ ****"},{"location":"#macro-details","title":"Macro Details","text":""},{"location":"#function","title":"FUNCTION","text":"<p>#define FUNCTION</p> <pre><code> @\n  @\n@@\n</code></pre>"},{"location":"Colors/","title":"Colors","text":"<p>class Colors</p> <p>This class defined a good set of ANSI colors.</p> <p>Tip</p> <p>It is recomended to use those through streams : std::cout &lt;&lt; Flint::Colors::GREEN &lt;&lt; \"Hacker time\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl;</p> <p>Info</p> <p>Please ALWAYS remember to close your colors with Flint::Colors::RESET. Failure to do si might result in broken displays, with weird colors everywhere</p>"},{"location":"CxxABI/","title":"CxxABI","text":"<p>class CxxABI</p> <p>Wrapper around usefull C++/C low level functions</p> <p>Got demangle, backtrace...</p> <p>Tip</p> <p>This class is only made of static functions. It does not contain constructor, nor destructor This means that you don't need to instanciate it, and only use it as if it was a namespace.</p>"},{"location":"CxxABI/#functions","title":"Functions","text":"Name Description demangle Demangle a C++ name. getFuncInfos Get functions infos from symbol extraction  Return :    A pair with the function names demangled, and the offset from the function !!! warning The function name is not EXACTLY the real name of the function. Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions getBacktrace Retreive the execution trace  Return :    Vector of pair, string&gt;. I'll explain The idea is to retrieive the file, line, and function. So that's what we do : pair or : (file, line), function !!! warning To correctly grab function names, you will need to add compilation flag \"-rdynamic\" See this lib's CMakeLists.txt for implementation. This will export ALL symbols. If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output."},{"location":"CxxABI/#function-details","title":"Function Details","text":""},{"location":"CxxABI/#demangle","title":"demangle","text":"<p>static std::string demangle(const char* name)</p> <p>Demangle a C++ name.</p> <p>This is usefull for : Class names, backtrace...</p> Return string containing : demangled name, or original name, if demangle did not work"},{"location":"CxxABI/#getbacktrace","title":"getBacktrace","text":"<p>static std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; getBacktrace()</p> <p>Retreive the execution trace</p> Return Vector of pair, string&gt;. I'll explain <p>The idea is to retrieive the file, line, and function. So that's what we do : pair or : (file, line), function</p> <p>Warning</p> <p>To correctly grab function names, you will need to add compilation flag \"-rdynamic\" See this lib's CMakeLists.txt for implementation. This will export ALL symbols. If NOT done, you will get offsets from binary. It's ok, but quite disgusting on output.</p>"},{"location":"CxxABI/#getfuncinfos","title":"getFuncInfos","text":"<p>static std::pair&lt;std::string, std::size_t&gt; getFuncInfos(const char* symbolInfos)</p> <p>Get functions infos from symbol extraction</p> Return A pair with the function names demangled, and the offset from the function <p>Warning</p> <p>The function name is not EXACTLY the real name of the function. Also, the offset DOES NOT correspond to the line number, but the offset of asm instructions</p>"},{"location":"Exception/","title":"Exception","text":"<p>class Exception: public std::exception</p> <p>Wrapper arround default std::exception</p> <p>Store the the exception description as std::string, and store some usefull localisation informations: Filename, Line, and Function Name. This is automated using the throw_exception preprocessor directive.</p> <p>Tip</p> <p>Take a look at the NotImplementedError to see how easy it is to implmeent your own Flint::Exception.</p>"},{"location":"Exception/#operators","title":"Operators","text":"Name Description operator&lt;&lt; operator&lt;&lt; override !!! abstract This will simply append the _what to the ostream"},{"location":"Exception/#functions","title":"Functions","text":"Name Description Exception Exception constructor. getInfos Retreive given infos (filename, line, and function name)  Return :    The actual infos getClassNameFromStackTrace Try to retreive the Exception class name from the StackTrace. show Display the error, given specific positional infos (like the constructor). what Required override, deprecated by show and catch_exception."},{"location":"Exception/#operator-details","title":"Operator Details","text":""},{"location":"Exception/#operator","title":"operator&lt;&lt;","text":"<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp;                os, const Exceptions::Exception&amp; obj)</p> <p>operator&lt;&lt; override</p> <p>Abstract</p> <p>This will simply append the _what to the ostream</p>"},{"location":"Exception/#function-details","title":"Function Details","text":""},{"location":"Exception/#exception_1","title":"Exception","text":"<p>Exception(const std::string&amp;     what  = \"An exception occured !\", std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos = { {\"\", 0}, \"\" })</p> <p>Exception constructor. This need to be called, even on child     classes.</p> <code>what</code> Define the exception's description <code>infos</code> Might contain positional infos <p>Warning</p> <p>You should NOT use any excpetion constructor manually. While they might work, the prefered way is to use the throw_exception preprocessor directive. Using it will only require you to register what type of excpetion you want to throw, and what message you want to add, and will take care of putting file name, line, and function name</p>"},{"location":"Exception/#getclassnamefromstacktrace","title":"getClassNameFromStackTrace","text":"<p>std::string getClassNameFromStackTrace( const std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const</p> <p>Try to retreive the Exception class name from the StackTrace.</p> <code>stackTrace</code> A stack trace, formated like CxxABI::getBacktrace() <p>Warning</p> <p>This function DOES NOT WORK 100% OF THE TIME. It is really dependant on the environement, and can return undefined without aparent reason. It should NOT be used for anything else than debug or display.</p> Return The actual class name or \"[Class name undefined]\""},{"location":"Exception/#getinfos","title":"getInfos","text":"<p>std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; getInfos() const</p> <p>Retreive given infos (filename, line, and function name)</p> Return The actual infos"},{"location":"Exception/#show","title":"show","text":"<p>std::string show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos) const</p> <p>Display the error, given specific positional infos (like the constructor).</p> <code>infos</code> Positional informations, like the constructor, used to display the infos. <p>Note</p> <p>This function, while being usable without, should be used through the catch_exception preprocessor directive. This preprocessor directive let you display Python like excpetion trace.</p> Return The formated exception, ready to be displayed."},{"location":"Exception/#what","title":"what","text":"<p>const char* what() const noexcept override</p> <p>Required override, deprecated by show and catch_exception.</p> <p>Info</p> <p>This is the required std::exception override. It'll return the _what as a const char*. While this will work, prefer using the show function or the catch_excpetion preprocessor directive :</p> <p>Example</p> <pre><code>try {\nthrow_exception(Flint::Exceptions::Exception, \"Sample testing\nexception\"); } catch (const Flint::Exceptions::Exception&amp; e) {\nstd::cerr &lt;&lt; catch_exception(e) &lt;&lt; std::endl;\n}\n</code></pre> Return The _what as a C string"},{"location":"Inspection/","title":"Inspection","text":"<p>template&lt;typename T&gt; class Inspection</p> <p>Base class to implement simplet self-reflexion in C++</p> <code>T</code> Child class itself <p>Tip</p> <p>When creating a child class, define as follow : <pre><code>class ChildClass: public Inspection&lt;ChildClass&gt;\n</code></pre> This will extand the ChildClass with the self-reflexion class Inspection</p> <p>Warning</p> <p>If the class you want to extand as a reflected class will be a parent class (I.E. You will create childs of this \"target\" class), you might want to mark inheritence as virtual. This is needed if your child class also need to be reflected. This way, there is no confilict between the parent reflexion, and the child reflexion.</p>"},{"location":"Inspection/#operators","title":"Operators","text":"Name Description operator&lt;&lt; Overload the operator &lt;&lt; to use the str method of the object  <code>T</code> :    Reflected class  <code>os</code> :    Reference of ostream (I.E. std::cout, std::cerr...)  <code>obj</code> :    Object reference to be displayed  Return :    Param os"},{"location":"Inspection/#functions","title":"Functions","text":"Name Description getClassName Return the name of the reflected class  Return :    The demangled name of the class, or just the name, if demangleing failed str Return a string representation of the class !!! tip This function is not intended to be used. This is because this functions display the reflection. You might prefer to override this function in yout child class to display informations that are more relevant to your specific class. !!! example You have a Macro available to make the str function really easilly : <code>cpp display_attr(attribute)</code> Which will automaticly translate to <code>cpp Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt; Flint::Colors::RESET</code> There is also a <code>make_str</code> macro, which you can use as follow : <code>cpp return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");</code> that becomes <code>cpp return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName() &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\" &lt;&lt; \"&gt;\"; ss.str()})</code> It means you can define the str function of your class as like that : <code>cpp // Provided you have 3 attributes called a, b and c return make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \", \" &lt;&lt; display_attr(c));</code> Return :    The string representation of the class"},{"location":"Inspection/#operator-details","title":"Operator Details","text":""},{"location":"Inspection/#operator","title":"operator&lt;&lt;","text":"<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp;        os, const Inspection&lt;T&gt;&amp; obj)</p> <p>Overload the operator &lt;&lt; to use the str method of the object</p> <code>T</code> Reflected class <code>os</code> Reference of ostream (I.E. std::cout, std::cerr...) <code>obj</code> Object reference to be displayed Return Param os"},{"location":"Inspection/#function-details","title":"Function Details","text":""},{"location":"Inspection/#getclassname","title":"getClassName","text":"<p>virtual std::string getClassName() const final</p> <p>Return the name of the reflected class</p> Return The demangled name of the class, or just the name, if demangleing failed"},{"location":"Inspection/#str","title":"str","text":"<p>virtual std::string str() const</p> <p>Return a string representation of the class</p> <p>Tip</p> <p>This function is not intended to be used. This is because this functions display the reflection. You might prefer to override this function in yout child class to display informations that are more relevant to your specific class.</p> <p>Example</p> <p>You have a Macro available to make the str function really easilly : <pre><code>display_attr(attribute)\n</code></pre> Which will automaticly translate to <pre><code>Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt;\n\"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt;\nFlint::Colors::RESET\n</code></pre> There is also a <code>make_str</code> macro, which you can use as follow : <pre><code>return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");\n</code></pre> that becomes <pre><code>return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName()\n&lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\"\n&lt;&lt; \"&gt;\"; ss.str()})\n</code></pre> It means you can define the str function of your class as like that : <pre><code>// Provided you have 3 attributes called a, b and c\nreturn make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \",\n\" &lt;&lt; display_attr(c));\n</code></pre></p> Return The string representation of the class"},{"location":"NotImplementedError/","title":"NotImplementedError","text":"<p>class NotImplementedError: public Flint::Exceptions::Exception</p> <p>Sample Flint::Exceptions::Exception to register NotImplemented features</p> <p>Tip</p> <p>You should use that Exception as a C++ Implementation of the Rust todo!() macro.</p> <p>Example</p> <pre><code>throw_exception(Flint::Exceptions::NotImplementedError, \"This function\nhaven't been implemented as of today !\");\n</code></pre>"},{"location":"Flint/","title":"Flint","text":"<pre><code> @\n  @\n@@\n</code></pre> <pre><code> @\n  @\n@@\n</code></pre> <pre><code> @\n  @\n@@\n</code></pre> <pre><code> @\n  @\n@@\n</code></pre> <pre><code> @\n  @\n@@\n</code></pre> <pre><code> @\n  @\n@@\n</code></pre> <pre><code> @\n  @\n@@\n</code></pre> <pre><code> @\n  @\n@@\n</code></pre> <pre><code> @\n  @\n@@\n</code></pre> Exceptions ** @ @ @@ * * @ @ @@ ****"},{"location":"Flint/Exceptions/","title":"Exceptions","text":"<pre><code> @\n  @\n@@\n</code></pre> <pre><code> @\n  @\n@@\n</code></pre>"},{"location":"coverage/","title":"Code Coverage","text":"Name Lines Covered Uncovered Coverage backend 272 0 272 0.0% Plugins 9 0 9 0.0% Protocols 6 0 6 0.0% Protocol-test 6 0 6 0.0% protocol-test.cpp 6 0 6 0.0% protocol-test.hpp 0 0 0 100.0% Tools 3 0 3 0.0% Tool-test 3 0 3 0.0% tool-test.cpp 3 0 3 0.0% tool-test.hpp 0 0 0 100.0% flint 145 0 145 0.0% src 145 0 145 0.0% Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 31 0 31 0.0% CxxABI.cpp 31 0 31 0.0% CxxABI.hpp 0 0 0 100.0% Exceptions 44 0 44 0.0% Exceptions.cpp 43 0 43 0.0% Exceptions.hpp 1 0 1 0.0% Init 16 0 16 0.0% Init.cpp 16 0 16 0.0% Init.hpp 0 0 0 100.0% Logging 46 0 46 0.0% Logging.cpp 45 0 45 0.0% Logging.hpp 1 0 1 0.0% hpp 7 0 7 0.0% Inspection.hpp 7 0 7 0.0% Preprocessor.hpp 0 0 0 100.0% Flint.hpp 0 0 0 100.0% Headers.hpp 1 0 1 0.0% src 118 0 118 0.0% PluginSystem 108 0 108 0.0% Protocol 1 0 1 0.0% AProtocol.hpp 1 0 1 0.0% Tool 1 0 1 0.0% ATool.hpp 1 0 1 0.0% IPlugin.hpp 0 0 0 100.0% PluginHotloader.cpp 44 0 44 0.0% PluginHotloader.hpp 0 0 0 100.0% PluginLoader.cpp 62 0 62 0.0% PluginLoader.hpp 0 0 0 100.0% main.cpp 10 0 10 0.0% Summary 6 0 6 0.0% Summary 6 0 6 0.0% Summary 3 0 3 0.0% Summary 3 0 3 0.0% Summary 9 0 9 0.0% Summary 0 0 0 100.0% Summary 31 0 31 0.0% Summary 44 0 44 0.0% Summary 16 0 16 0.0% Summary 46 0 46 0.0% Summary 7 0 7 0.0% Summary 145 0 145 0.0% Summary 145 0 145 0.0% Summary 1 0 1 0.0% Summary 1 0 1 0.0% Summary 108 0 108 0.0% Summary 118 0 118 0.0% Summary 272 0 272 0.0% Summary 272 0 272 0.0%"},{"location":"coverage/backend/","title":"backend","text":"Name Lines Covered Uncovered Coverage Plugins 9 0 9 0.0% Protocols 6 0 6 0.0% Protocol-test 6 0 6 0.0% protocol-test.cpp 6 0 6 0.0% protocol-test.hpp 0 0 0 100.0% Tools 3 0 3 0.0% Tool-test 3 0 3 0.0% tool-test.cpp 3 0 3 0.0% tool-test.hpp 0 0 0 100.0% flint 145 0 145 0.0% src 145 0 145 0.0% Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 31 0 31 0.0% CxxABI.cpp 31 0 31 0.0% CxxABI.hpp 0 0 0 100.0% Exceptions 44 0 44 0.0% Exceptions.cpp 43 0 43 0.0% Exceptions.hpp 1 0 1 0.0% Init 16 0 16 0.0% Init.cpp 16 0 16 0.0% Init.hpp 0 0 0 100.0% Logging 46 0 46 0.0% Logging.cpp 45 0 45 0.0% Logging.hpp 1 0 1 0.0% hpp 7 0 7 0.0% Inspection.hpp 7 0 7 0.0% Preprocessor.hpp 0 0 0 100.0% Flint.hpp 0 0 0 100.0% Headers.hpp 1 0 1 0.0% src 118 0 118 0.0% PluginSystem 108 0 108 0.0% Protocol 1 0 1 0.0% AProtocol.hpp 1 0 1 0.0% Tool 1 0 1 0.0% ATool.hpp 1 0 1 0.0% IPlugin.hpp 0 0 0 100.0% PluginHotloader.cpp 44 0 44 0.0% PluginHotloader.hpp 0 0 0 100.0% PluginLoader.cpp 62 0 62 0.0% PluginLoader.hpp 0 0 0 100.0% main.cpp 10 0 10 0.0% Summary 6 0 6 0.0% Summary 6 0 6 0.0% Summary 3 0 3 0.0% Summary 3 0 3 0.0% Summary 9 0 9 0.0% Summary 0 0 0 100.0% Summary 31 0 31 0.0% Summary 44 0 44 0.0% Summary 16 0 16 0.0% Summary 46 0 46 0.0% Summary 7 0 7 0.0% Summary 145 0 145 0.0% Summary 145 0 145 0.0% Summary 1 0 1 0.0% Summary 1 0 1 0.0% Summary 108 0 108 0.0% Summary 118 0 118 0.0% Summary 272 0 272 0.0%"},{"location":"coverage/backend/Plugins/","title":"Plugins","text":"Name Lines Covered Uncovered Coverage Protocols 6 0 6 0.0% Protocol-test 6 0 6 0.0% protocol-test.cpp 6 0 6 0.0% protocol-test.hpp 0 0 0 100.0% Tools 3 0 3 0.0% Tool-test 3 0 3 0.0% tool-test.cpp 3 0 3 0.0% tool-test.hpp 0 0 0 100.0% Summary 6 0 6 0.0% Summary 6 0 6 0.0% Summary 3 0 3 0.0% Summary 3 0 3 0.0% Summary 9 0 9 0.0%"},{"location":"coverage/backend/Plugins/Protocols/","title":"Protocols","text":"Name Lines Covered Uncovered Coverage Protocol-test 6 0 6 0.0% protocol-test.cpp 6 0 6 0.0% protocol-test.hpp 0 0 0 100.0% Summary 6 0 6 0.0% Summary 6 0 6 0.0%"},{"location":"coverage/backend/Plugins/Protocols/Protocol_u002dtest/","title":"Protocol-test","text":"Name Lines Covered Uncovered Coverage protocol-test.cpp 6 0 6 0.0% protocol-test.hpp 0 0 0 100.0% Summary 6 0 6 0.0%"},{"location":"coverage/backend/Plugins/Protocols/Protocol_u002dtest/protocol_u002dtest.cpp/","title":"protocol-test.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2025\n** tek4\n** File description:\n** protocol-test\n*/\n\n#include \"protocol-test.hpp\"\n\nPluginSystem::ProtocolTest::~ProtocolTest() {\n}\n\nvoid PluginSystem::ProtocolTest::toggle() {\nif (connected) {\ndisconnect();\n} else {\nconnect();\n}\n}\n\nvoid PluginSystem::ProtocolTest::connect() {\nconnected = true;\n}\n\nvoid PluginSystem::ProtocolTest::disconnect() {\nconnected = false;\n}\n\nbool PluginSystem::ProtocolTest::isConnected() const {\nreturn connected;\n}\n\nextern \"C\" PluginSystem::ProtocolTest *instance(void)\n{\nreturn new PluginSystem::ProtocolTest();\n}\n</code></pre>"},{"location":"coverage/backend/Plugins/Protocols/Protocol_u002dtest/protocol_u002dtest.hpp/","title":"protocol-test.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2025\n** tek4\n** File description:\n** protocol-test\n*/\n\n#ifndef PROTOCOL_TEST_HPP_\n#define PROTOCOL_TEST_HPP_\n\n#include \"PluginSystem/Protocol/AProtocol.hpp\"\n\nnamespace PluginSystem {\nclass ProtocolTest : public AProtocol {\npublic:\n~ProtocolTest();\n\n//* Plugin Related Methods *//\nvoid toggle();\n\n//* Protocol Specific Methods *//\nvoid connect();\nvoid disconnect();\nbool isConnected() const;\n\nprivate:\nbool connected = false;\n};\n}\n\n#endif /* !PROTOCOL_TEST_HPP_ */\n</code></pre>"},{"location":"coverage/backend/Plugins/Tools/","title":"Tools","text":"Name Lines Covered Uncovered Coverage Tool-test 3 0 3 0.0% tool-test.cpp 3 0 3 0.0% tool-test.hpp 0 0 0 100.0% Summary 3 0 3 0.0% Summary 3 0 3 0.0%"},{"location":"coverage/backend/Plugins/Tools/Tool_u002dtest/","title":"Tool-test","text":"Name Lines Covered Uncovered Coverage tool-test.cpp 3 0 3 0.0% tool-test.hpp 0 0 0 100.0% Summary 3 0 3 0.0%"},{"location":"coverage/backend/Plugins/Tools/Tool_u002dtest/tool_u002dtest.cpp/","title":"tool-test.cpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2025\n** tek4\n** File description:\n** tool-test\n*/\n\n#include \"tool-test.hpp\"\n\nPluginSystem::ToolTest::~ToolTest() {\n}\n\nvoid PluginSystem::ToolTest::toggle() {\nisActive = !isActive;\n}\n\nvoid PluginSystem::ToolTest::execute() {\nstd::cout &lt;&lt; \"ToolTest executed, isActive: \" &lt;&lt; isActive &lt;&lt; std::endl;\n}\n\nextern \"C\" PluginSystem::ToolTest *instance(void)\n{\nreturn new PluginSystem::ToolTest();\n}\n</code></pre>"},{"location":"coverage/backend/Plugins/Tools/Tool_u002dtest/tool_u002dtest.hpp/","title":"tool-test.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2025\n** tek4\n** File description:\n** tool-test\n*/\n\n#ifndef TOOL_TEST_HPP_\n#define TOOL_TEST_HPP_\n\n#include \"PluginSystem/Tool/ATool.hpp\"\n#include &lt;iostream&gt;\n\nnamespace PluginSystem {\nclass ToolTest : public ATool {\npublic:\n~ToolTest();\n\n//* Plugin Related Methods *//\nvoid toggle();\n\n//* Tool Specific Methods *//\nvoid execute();\n\nprivate:\nbool isActive = false;\n};\n}\n\n#endif /* !TOOL_TEST_HPP_ */\n</code></pre>"},{"location":"coverage/backend/flint/","title":"flint","text":"Name Lines Covered Uncovered Coverage src 145 0 145 0.0% Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 31 0 31 0.0% CxxABI.cpp 31 0 31 0.0% CxxABI.hpp 0 0 0 100.0% Exceptions 44 0 44 0.0% Exceptions.cpp 43 0 43 0.0% Exceptions.hpp 1 0 1 0.0% Init 16 0 16 0.0% Init.cpp 16 0 16 0.0% Init.hpp 0 0 0 100.0% Logging 46 0 46 0.0% Logging.cpp 45 0 45 0.0% Logging.hpp 1 0 1 0.0% hpp 7 0 7 0.0% Inspection.hpp 7 0 7 0.0% Preprocessor.hpp 0 0 0 100.0% Flint.hpp 0 0 0 100.0% Headers.hpp 1 0 1 0.0% Summary 0 0 0 100.0% Summary 31 0 31 0.0% Summary 44 0 44 0.0% Summary 16 0 16 0.0% Summary 46 0 46 0.0% Summary 7 0 7 0.0% Summary 145 0 145 0.0% Summary 145 0 145 0.0%"},{"location":"coverage/backend/flint/src/","title":"src","text":"Name Lines Covered Uncovered Coverage Colors 0 0 0 100.0% Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% CxxABI 31 0 31 0.0% CxxABI.cpp 31 0 31 0.0% CxxABI.hpp 0 0 0 100.0% Exceptions 44 0 44 0.0% Exceptions.cpp 43 0 43 0.0% Exceptions.hpp 1 0 1 0.0% Init 16 0 16 0.0% Init.cpp 16 0 16 0.0% Init.hpp 0 0 0 100.0% Logging 46 0 46 0.0% Logging.cpp 45 0 45 0.0% Logging.hpp 1 0 1 0.0% hpp 7 0 7 0.0% Inspection.hpp 7 0 7 0.0% Preprocessor.hpp 0 0 0 100.0% Flint.hpp 0 0 0 100.0% Headers.hpp 1 0 1 0.0% Summary 0 0 0 100.0% Summary 31 0 31 0.0% Summary 44 0 44 0.0% Summary 16 0 16 0.0% Summary 46 0 46 0.0% Summary 7 0 7 0.0% Summary 145 0 145 0.0%"},{"location":"coverage/backend/flint/src/Flint.hpp/","title":"Flint.hpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#ifndef INCLUDED_FLINT_HPP\n#define INCLUDED_FLINT_HPP\n\n#include \"Colors/Colors.hpp\"\n#include \"CxxABI/CxxABI.hpp\"\n#include \"Exceptions/Exceptions.hpp\"\n#include \"Headers.hpp\"\n#include \"hpp/Inspection.hpp\"\n#include \"Init/Init.hpp\"\n#include \"Logging/Logging.hpp\"\n\n#endif\n</code></pre>"},{"location":"coverage/backend/flint/src/Headers.hpp/","title":"Headers.hpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#ifndef INCLUDED_HEADERS_HPP\n#define INCLUDED_HEADERS_HPP\n\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;cxxabi.h&gt;\n#include &lt;exception&gt;\n#include &lt;filesystem&gt;\n#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;optional&gt;\n#include &lt;ostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace fs = std::filesystem;\n\n// get break trace\n#ifdef _WIN32\n#include &lt;windows.h&gt;\n#elif defined(__linux__) || defined(__APPLE__)\n#include &lt;execinfo.h&gt;\n#endif\n\n#endif\n</code></pre>"},{"location":"coverage/backend/flint/src/Colors/","title":"Colors","text":"Name Lines Covered Uncovered Coverage Colors.cpp 0 0 0 100.0% Colors.hpp 0 0 0 100.0% Summary 0 0 0 100.0%"},{"location":"coverage/backend/flint/src/Colors/Colors.cpp/","title":"Colors.cpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#include \"Colors.hpp\"\n\nnamespace Flint\n{\nconst std::string Colors::RESET       = \"\\033[0m\";\nconst std::string Colors::BOLD        = \"\\033[1m\";\nconst std::string Colors::DISABLED    = \"\\033[2m\";\nconst std::string Colors::ITALIC      = \"\\033[3m\";\nconst std::string Colors::UNDERLINE   = \"\\033[4m\";\nconst std::string Colors::BLINK       = \"\\033[5m\";\nconst std::string Colors::HIGHLIGHTED = \"\\033[7m\";\nconst std::string Colors::STRIPED     = \"\\033[9m\";\nconst std::string Colors::BLACK       = \"\\033[30m\";\nconst std::string Colors::RED         = \"\\033[31m\";\nconst std::string Colors::GREEN       = \"\\033[32m\";\nconst std::string Colors::YELLOW      = \"\\033[33m\";\nconst std::string Colors::BLUE        = \"\\033[34m\";\nconst std::string Colors::PURPLE      = \"\\033[35m\";\nconst std::string Colors::CYAN        = \"\\033[36m\";\nconst std::string Colors::GREY        = \"\\033[2m\";\nconst std::string Colors::F_BLACK     = \"\\033[90m\";\nconst std::string Colors::F_RED       = \"\\033[91m\";\nconst std::string Colors::F_GREEN     = \"\\033[92m\";\nconst std::string Colors::F_YELLOW    = \"\\033[93m\";\nconst std::string Colors::F_BLUE      = \"\\033[94m\";\nconst std::string Colors::F_PURPLE    = \"\\033[95m\";\nconst std::string Colors::F_CYAN      = \"\\033[96m\";\nconst std::string Colors::F_GREY      = \"\\033[97m\";\nconst std::string Colors::B_BLACK     = \"\\033[40m\";\nconst std::string Colors::B_RED       = \"\\033[41m\";\nconst std::string Colors::B_GREEN     = \"\\033[42m\";\nconst std::string Colors::B_YELLOW    = \"\\033[43m\";\nconst std::string Colors::B_BLUE      = \"\\033[44m\";\nconst std::string Colors::B_PURPLE    = \"\\033[45m\";\nconst std::string Colors::B_CYAN      = \"\\033[46m\";\nconst std::string Colors::B_GREY      = \"\\033[47m\";\n}\n</code></pre>"},{"location":"coverage/backend/flint/src/Colors/Colors.hpp/","title":"Colors.hpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#ifndef INCLUDED_COLORS_HPP\n#define INCLUDED_COLORS_HPP\n\n#include \"../Headers.hpp\"\n\nnamespace Flint\n{\n/**\n     * This class defined a good set of ANSI colors.\n     *\n     * @ingroup flint\n     *\n     * @tip\n     * It is recomended to use those through streams :\n     * std::cout &lt;&lt; Flint::Colors::GREEN &lt;&lt; \"Hacker time\" &lt;&lt;\n     * Flint::Colors::RESET &lt;&lt; std::endl;\n     *\n     * @info\n     * Please ALWAYS remember to close your colors with Flint::Colors::RESET.\n     * Failure to do si might result in broken displays, with weird colors\n     * everywhere\n     */\nclass Colors\n{\npublic:\nstatic const std::string RESET;\nstatic const std::string BOLD;\nstatic const std::string DISABLED;\nstatic const std::string ITALIC;\nstatic const std::string UNDERLINE;\nstatic const std::string BLINK;\nstatic const std::string HIGHLIGHTED;\nstatic const std::string STRIPED;\nstatic const std::string BLACK;\nstatic const std::string RED;\nstatic const std::string GREEN;\nstatic const std::string YELLOW;\nstatic const std::string BLUE;\nstatic const std::string PURPLE;\nstatic const std::string CYAN;\nstatic const std::string GREY;\nstatic const std::string F_BLACK;\nstatic const std::string F_RED;\nstatic const std::string F_GREEN;\nstatic const std::string F_YELLOW;\nstatic const std::string F_BLUE;\nstatic const std::string F_PURPLE;\nstatic const std::string F_CYAN;\nstatic const std::string F_GREY;\nstatic const std::string B_BLACK;\nstatic const std::string B_RED;\nstatic const std::string B_GREEN;\nstatic const std::string B_YELLOW;\nstatic const std::string B_BLUE;\nstatic const std::string B_PURPLE;\nstatic const std::string B_CYAN;\nstatic const std::string B_GREY;\n};\n}\n\n#endif\n</code></pre>"},{"location":"coverage/backend/flint/src/CxxABI/","title":"CxxABI","text":"Name Lines Covered Uncovered Coverage CxxABI.cpp 31 0 31 0.0% CxxABI.hpp 0 0 0 100.0% Summary 31 0 31 0.0%"},{"location":"coverage/backend/flint/src/CxxABI/CxxABI.cpp/","title":"CxxABI.cpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#include \"CxxABI.hpp\"\n\nnamespace Flint\n{\nstd::string CxxABI::demangle(const char* name)\n{\nint   status = -4;\nchar* _out   = abi::__cxa_demangle(name, nullptr, nullptr, &amp;status);\nif (status != 0 &amp;&amp; _out) free(_out);\nif (status != 0) return std::string(name);\nstd::string result(_out);\nfree(_out);\nreturn result;\n}\n\nstd::pair&lt;std::string, std::size_t&gt;\nCxxABI::getFuncInfos(const char* symbolInfos)\n{\nstd::pair&lt;std::string, std::size_t&gt; output;\nstd::string                         entry(symbolInfos);\n\nstd::size_t openP  = entry.find('(');\nstd::size_t closeP = entry.find(')');\n\nif (openP == std::string::npos || closeP == std::string::npos)\nreturn output;\n\nstd::string functionAndOffset = entry.substr(openP + 1, closeP);\nstd::size_t plusP             = functionAndOffset.find('+');\n\nif (functionAndOffset.empty() || plusP == std::string::npos)\nreturn output;\n\noutput.first =\nCxxABI::demangle(functionAndOffset.substr(0, plusP).c_str());\nstd::stringstream ss;\nss &lt;&lt; std::hex &lt;&lt; functionAndOffset.substr(plusP + 1);\nss &gt;&gt; output.second;\n\nreturn output;\n}\n\n// std::vector&lt;std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;&gt;\n// CxxABI::getBacktrace()\nstd::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; CxxABI::getBacktrace()\n{\nstd::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; out;\nint                                              TRACE_CHUNCK = 128;\n\nint size = 0, out_size = 0;\ndo {\nsize += TRACE_CHUNCK;\nvoid* trace[size + 1];\nout_size = (int)backtrace(trace, size);\n} while (out_size == size);\nvoid* trace[out_size + 1];\n\nbacktrace(trace, out_size);\nchar** symbols = backtrace_symbols(trace, out_size);\nif (symbols) {\nfor (int i = 0; i &lt; out_size; ++i) {\nstd::pair&lt;std::string, std::size_t&gt; symbol =\nCxxABI::getFuncInfos(symbols[i]);\nif (symbol.first.empty()) break;\nout.push_back(symbol);\n}\nfree(symbols);\n}\n\nreturn out;\n}\n}\n</code></pre>"},{"location":"coverage/backend/flint/src/CxxABI/CxxABI.hpp/","title":"CxxABI.hpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#ifndef INCLUDED_CXXABI_HPP\n#define INCLUDED_CXXABI_HPP\n\n#include \"../Headers.hpp\"\n\nnamespace Flint\n{\n/**\n     * Wrapper around usefull C++/C low level functions\n     *\n     * @ingroup flint\n     *\n     * Got demangle, backtrace...\n     *\n     * @tip\n     * This class is only made of static functions. It does not contain\n     * constructor, nor destructor This means that you don't need to instanciate\n     * it, and only use it as if it was a namespace.\n     */\nclass CxxABI\n{\npublic:\nCxxABI() = delete;\n\n/**\n             * Demangle a C++ name.\n             *\n             * This is usefull for : Class names, backtrace...\n             *\n             * @return string containing : demangled name, or original name, if\n             * demangle did not work\n             */\nstatic std::string demangle(const char* name);\n\n/**\n             * Get functions infos from symbol extraction\n             *\n             * @return A pair with the function names demangled, and the offset\n             * from the function\n             *\n             * @warning\n             * The function name is not EXACTLY the real name of the function.\n             * Also, the offset DOES NOT correspond to the line number, but the\n             * offset of asm instructions\n             */\nstatic std::pair&lt;std::string, std::size_t&gt;\ngetFuncInfos(const char* symbolInfos);\n\n/**\n             * Retreive the execution trace\n             *\n             * @return Vector of pair&lt;pair&lt;string, size_t&gt;, string&gt;. I'll\n             * explain\n             *\n             * The idea is to retrieive the file, line, and function. So that's\n             * what we do : pair or : (file, line), function\n             *\n             * @warning\n             * To correctly grab function names, you will need to add\n             * compilation flag \"-rdynamic\" See this lib's CMakeLists.txt for\n             * implementation. This will export ALL symbols. If NOT done, you\n             * will get offsets from binary. It's ok, but quite disgusting on\n             * output.\n             */\nstatic std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;\ngetBacktrace();\n};\n}\n\n#endif\n</code></pre>"},{"location":"coverage/backend/flint/src/Exceptions/","title":"Exceptions","text":"Name Lines Covered Uncovered Coverage Exceptions.cpp 43 0 43 0.0% Exceptions.hpp 1 0 1 0.0% Summary 44 0 44 0.0%"},{"location":"coverage/backend/flint/src/Exceptions/Exceptions.cpp/","title":"Exceptions.cpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#include \"Exceptions.hpp\"\n\nnamespace Flint::Exceptions\n{\nException::Exception(\nconst std::string&amp;                                          what,\nstd::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; infos):\n_infos(infos)\n{\nstd::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt; stackTrace =\nCxxABI::getBacktrace();\nstd::stringstream ss;\n\nss &lt;&lt; \"[\" &lt;&lt; Flint::Colors::F_PURPLE\n&lt;&lt; this-&gt;getClassNameFromStackTrace(stackTrace)\n&lt;&lt; Flint::Colors::RESET;\n\nif (!infos.first.first.empty() &amp;&amp; !infos.second.empty()) {\nss &lt;&lt; \" in \" &lt;&lt; Flint::Colors::F_YELLOW &lt;&lt; infos.second\n&lt;&lt; Flint::Colors::RESET &lt;&lt; \" at \" &lt;&lt; Flint::Colors::F_BLUE\n&lt;&lt; infos.first.first.substr(\ninfos.first.first.find_last_of(\"/\\\\\") + 1)\n&lt;&lt; Flint::Colors::RESET &lt;&lt; \":\" &lt;&lt; Flint::Colors::F_RED\n&lt;&lt; infos.first.second &lt;&lt; Flint::Colors::RESET;\n}\nss &lt;&lt; \"] \" &lt;&lt; what;\n\nfor (std::size_t i = 2; i &lt; stackTrace.size(); i++) {\nstd::string funcName = stackTrace[i].first;\nstd::size_t openP    = funcName.find('(');\nif (openP == std::string::npos) funcName += \"()\";\nfuncName = funcName.substr(0, funcName.find(\"(\") + 1) + \"[...])\";\nss &lt;&lt; std::endl\n&lt;&lt; \" -&gt; \" &lt;&lt; Flint::Colors::CYAN &lt;&lt; funcName\n&lt;&lt; Flint::Colors::RESET &lt;&lt; \":\" &lt;&lt; Flint::Colors::YELLOW &lt;&lt; \"0x\"\n&lt;&lt; std::hex &lt;&lt; stackTrace[i].second &lt;&lt; Flint::Colors::RESET;\n}\n\nthis-&gt;_what = ss.str();\n}\n\nstd::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;\nException::getInfos() const\n{\nreturn this-&gt;_infos;\n}\n\nstd::string Exception::getClassNameFromStackTrace(\nconst std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp; stackTrace) const\n{\nif (stackTrace.size() &lt;= 2) return \"[Class name undefined]\";\n\nstd::string classNameSymbol = stackTrace[2].first.substr();\nstd::size_t openP           = classNameSymbol.find('(');\nif (openP == std::string::npos) return \"[Class name undefined]\";\n\nstd::string functionName = classNameSymbol.substr(0, openP);\nstd::size_t lastColon    = functionName.rfind(\"::\");\nif (lastColon == std::string::npos) return \"[Class name undefined]\";\n// Remove duplicate\nreturn functionName.substr(0, lastColon);\n}\n\nstd::string Exception::show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;,\nstd::string&gt; fileInfos) const\n{\nstd::stringstream ss;\nss &lt;&lt; \"Exception caught on \" &lt;&lt; Flint::Colors::F_GREEN\n&lt;&lt; fileInfos.second &lt;&lt; Flint::Colors::RESET &lt;&lt; \" at \"\n&lt;&lt; Flint::Colors::F_BLUE &lt;&lt; fileInfos.first.first\n&lt;&lt; Flint::Colors::RESET &lt;&lt; \":\" &lt;&lt; Flint::Colors::F_RED\n&lt;&lt; fileInfos.first.second &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl\n&lt;&lt; std::endl;\n\nss &lt;&lt; this-&gt;_what;\nreturn ss.str();\n}\n\nconst char* Exception::what() const noexcept\n{\nreturn this-&gt;_what.c_str();\n}\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Exceptions::Exception&amp; obj)\n{\nos &lt;&lt; obj.what();\nreturn os;\n}\n}\n</code></pre>"},{"location":"coverage/backend/flint/src/Exceptions/Exceptions.hpp/","title":"Exceptions.hpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#ifndef INCLUDED_EXCEPTIONS_HPP\n#define INCLUDED_EXCEPTIONS_HPP\n\n#include \"../Colors/Colors.hpp\"\n#include \"../CxxABI/CxxABI.hpp\"\n#include \"../Headers.hpp\"\n#include \"../hpp/Preprocessor.hpp\"\n\nnamespace Flint::Exceptions\n{\n/**\n     * Wrapper arround default\n     * [std::exception](https://en.cppreference.com/w/cpp/error/exception)\n     *\n     * @ingroup flint\n     *\n     * Store the the exception description as\n     * [std::string](https://en.cppreference.com/w/cpp/string/basic_string), and\n     * store some usefull localisation informations: Filename, Line, and\n     * Function Name. This is automated using the throw_exception preprocessor\n     * directive.\n     *\n     * @tip\n     * Take a look at the NotImplementedError to see how easy it is to implmeent\n     * your own Flint::Exception.\n     */\nclass Exception: public std::exception\n{\nprotected:\nstd::string                                                 _what;\nstd::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt; _infos;\n\npublic:\n/**\n             * Exception constructor. This need to be called, even on child\n             * classes.\n             *\n             * @param what Define the exception's description\n             * @param infos Might contain positional infos\n             *\n             * @warning\n             * You should **NOT** use any excpetion constructor manually.\n             * While they might work, the prefered way is to use the\n             * throw_exception preprocessor directive. Using it will only\n             * require you to register what type of excpetion you want to throw,\n             * and what message you want to add, and will take care of putting\n             * file name, line, and function name\n             */\nException(const std::string&amp;     what  = \"An exception occured !\",\nstd::pair&lt;std::pair&lt;std::string, std::size_t&gt;,\nstd::string&gt; infos = {\n{\"\", 0},\n\"\"\n});\n\n/**\n             * Retreive given infos (filename, line, and function name)\n             *\n             * @return The actual infos\n             */\nstd::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;\ngetInfos() const;\n\n/**\n             * Try to retreive the Exception class name from the StackTrace.\n             *\n             * @param stackTrace A stack trace, formated like\n             * CxxABI::getBacktrace()\n             *\n             * @warning\n             * This function **DOES NOT WORK 100% OF THE TIME**.\n             * It is really dependant on the environement, and can return\n             * undefined without aparent reason. It should **NOT** be used for\n             * anything else than debug or display.\n             *\n             * @return The actual class name or \"[Class name undefined]\"\n             */\nstd::string getClassNameFromStackTrace(\nconst std::vector&lt;std::pair&lt;std::string, std::size_t&gt;&gt;&amp;\nstackTrace) const;\n\n/**\n             * Display the error, given specific positional infos (like the\n             * constructor).\n             *\n             * @param infos Positional informations, like the constructor, used\n             * to display the infos.\n             *\n             * @note\n             * This function, while being usable without, should be used through\n             * the catch_exception preprocessor directive. This preprocessor\n             * directive let you display Python like excpetion trace.\n             *\n             * @return The formated exception, ready to be displayed.\n             */\nstd::string show(std::pair&lt;std::pair&lt;std::string, std::size_t&gt;,\nstd::string&gt; infos) const;\n\n/**\n             * Required override, deprecated by show and catch_exception.\n             *\n             * @info\n             * This is the required std::exception override.\n             * It'll return the _what as a const char*.\n             * While this will work, prefer using the show function or the\n             * catch_excpetion preprocessor directive :\n             *\n             * @example\n             * ```cpp\n             * try {\n             *     throw_exception(Flint::Exceptions::Exception, \"Sample testing\n             * exception\"); } catch (const Flint::Exceptions::Exception&amp; e) {\n             *     std::cerr &lt;&lt; catch_exception(e) &lt;&lt; std::endl;\n             * }\n             * ```\n             *\n             * @return The _what as a C string\n             */\nconst char* what() const noexcept override;\n\n/**\n             * operator&lt;&lt; override\n             *\n             * @abstract\n             * This will simply append the _what to the ostream\n             */\nfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;                os,\nconst Exceptions::Exception&amp; obj);\n};\n\n/**\n     * Sample Flint::Exceptions::Exception to register NotImplemented features\n     *\n     * @ingroup flint\n     *\n     * @tip\n     * You should use that Exception as a C++ Implementation of the Rust todo!()\n     * macro.\n     *\n     * @example\n     * ```cpp\n     * throw_exception(Flint::Exceptions::NotImplementedError, \"This function\n     * haven't been implemented as of today !\");\n     * ```\n     */\nclass NotImplementedError: public Flint::Exceptions::Exception\n{\npublic:\nNotImplementedError(const std::string&amp; what =\n\"Asked action haven't been implemented yet.\",\nstd::pair&lt;std::pair&lt;std::string, std::size_t&gt;,\nstd::string&gt; infos = {{\"\", 0}, \"\"}):\nException(what, infos)\n{\n}\n};\n}\n\n#endif\n</code></pre>"},{"location":"coverage/backend/flint/src/Init/","title":"Init","text":"Name Lines Covered Uncovered Coverage Init.cpp 16 0 16 0.0% Init.hpp 0 0 0 100.0% Summary 16 0 16 0.0%"},{"location":"coverage/backend/flint/src/Init/Init.cpp/","title":"Init.cpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#include \"Init.hpp\"\n\nnamespace Flint\n{\nstatic void unhandeled_exception()\n{\ntry {\nstd::rethrow_exception(std::current_exception());\n} catch (const std::exception&amp; e) {\nconst Flint::Exceptions::Exception* exception =\ndynamic_cast&lt;const Flint::Exceptions::Exception*&gt;(&amp;e);\nif (exception != nullptr) {\nstd::cerr &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\"\n&lt;&lt; Flint::Colors::RESET\n&lt;&lt; \" Uncaught Flint exception \" &lt;&lt; Flint::Colors::RED\n&lt;&lt; \"/!\\\\\" &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl\n&lt;&lt; std::endl\n&lt;&lt; *exception &lt;&lt; std::endl;\n} else {\nstd::cerr &lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\"\n&lt;&lt; Flint::Colors::RESET &lt;&lt; \" Uncaught exception \"\n&lt;&lt; Flint::Colors::RED &lt;&lt; \"/!\\\\\"\n&lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl\n&lt;&lt; std::endl\n&lt;&lt; e.what() &lt;&lt; std::endl;\n}\n}\n}\n\nvoid Init()\n{\nstd::set_terminate(unhandeled_exception);\n}\n}\n</code></pre>"},{"location":"coverage/backend/flint/src/Init/Init.hpp/","title":"Init.hpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#ifndef INCLUDED_INIT_HPP\n#define INCLUDED_INIT_HPP\n\n#include \"../Exceptions/Exceptions.hpp\"\n\nnamespace Flint\n{\n[[gnu::constructor]] void Init();\n}\n\n#endif\n</code></pre>"},{"location":"coverage/backend/flint/src/Logging/","title":"Logging","text":"Name Lines Covered Uncovered Coverage Logging.cpp 45 0 45 0.0% Logging.hpp 1 0 1 0.0% Summary 46 0 46 0.0%"},{"location":"coverage/backend/flint/src/Logging/Logging.cpp/","title":"Logging.cpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#include \"Logging.hpp\"\n\n#include &lt;optional&gt;\n\nnamespace Flint\n{\nLogging&amp; Logging::get()\n{\nstatic Logging instance;\nreturn instance;\n}\n\nvoid Logging::set_log_on_stderr(bool log_on_stderr)\n{\nLogging::get().log_on_stderr = log_on_stderr;\n}\n\nvoid Logging::set_log_level(LogLevel level)\n{\nLogging::get().display_level = level;\n}\n\nvoid Logging::set_error_level(LogLevel level)\n{\nLogging::get().error_level = level;\n}\n\nvoid Logging::display_positional_infos(\nstd::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;\npositional_infos)\n{\nstd::cout &lt;&lt; \"(at \" &lt;&lt; Flint::Colors::CYAN\n&lt;&lt; positional_infos.first.first &lt;&lt; Flint::Colors::RESET &lt;&lt; \":\"\n&lt;&lt; Flint::Colors::PURPLE &lt;&lt; positional_infos.first.second\n&lt;&lt; Flint::Colors::RESET &lt;&lt; \" in \" &lt;&lt; Flint::Colors::BLUE\n&lt;&lt; positional_infos.second &lt;&lt; Flint::Colors::RESET &lt;&lt; \") \";\n}\n\nvoid Logging::debug(\nconst std::string&amp; message,\nstd::optional&lt;std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;&gt;\npositional_infos)\n{\nstd::cout &lt;&lt; \"[ \" &lt;&lt; Flint::Colors::GREY &lt;&lt; \"DEBG\"\n&lt;&lt; Flint::Colors::RESET &lt;&lt; \" ] \";\n\nif (positional_infos)\nLogging::display_positional_infos(*positional_infos);\n\nstd::cout &lt;&lt; message &lt;&lt; std::endl;\n\nauto backtrace = Flint::CxxABI::getBacktrace();\n\nfor (auto entry: backtrace)\nstd::cout &lt;&lt; \"    in \" &lt;&lt; Flint::Colors::PURPLE &lt;&lt; entry.first\n&lt;&lt; Flint::Colors::RESET &lt;&lt; \":\" &lt;&lt; Flint::Colors::GREEN\n&lt;&lt; entry.second &lt;&lt; Flint::Colors::RESET &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"== End Debug Backtrace ==\" &lt;&lt; std::endl;\n\nif (Logging::get().error_level &lt;= Flint::LogLevel::DEBUG)\nthrow_exception(Flint::TooHighLevelLoggingError, message);\n}\n\nvoid Logging::info(\nconst std::string&amp; message,\nstd::optional&lt;std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;&gt;\npositional_infos)\n{\nstd::cout &lt;&lt; \"[ \" &lt;&lt; Flint::Colors::GREEN &lt;&lt; \"INFO\"\n&lt;&lt; Flint::Colors::RESET &lt;&lt; \" ] \";\n\nif (positional_infos)\nLogging::display_positional_infos(*positional_infos);\n\nstd::cout &lt;&lt; message &lt;&lt; std::endl;\n\nif (Logging::get().error_level &lt;= Flint::LogLevel::INFO)\nthrow_exception(Flint::TooHighLevelLoggingError, message);\n}\n\nvoid Logging::warning(\nconst std::string&amp; message,\nstd::optional&lt;std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;&gt;\npositional_infos)\n{\nstd::cout &lt;&lt; \"[ \" &lt;&lt; Flint::Colors::YELLOW &lt;&lt; \"WARN\"\n&lt;&lt; Flint::Colors::RESET &lt;&lt; \" ] \";\n\nif (positional_infos)\nLogging::display_positional_infos(*positional_infos);\n\nstd::cout &lt;&lt; message &lt;&lt; std::endl;\n\nif (Logging::get().error_level &lt;= Flint::LogLevel::WARNING)\nthrow_exception(Flint::TooHighLevelLoggingError, message);\n}\n\nvoid Logging::error(\nconst std::string&amp; message,\nstd::optional&lt;std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;&gt;\npositional_infos)\n{\nstd::cout &lt;&lt; \"[ \" &lt;&lt; Flint::Colors::RED &lt;&lt; \"FAIL\"\n&lt;&lt; Flint::Colors::RESET &lt;&lt; \" ] \";\n\nif (positional_infos)\nLogging::display_positional_infos(*positional_infos);\n\nstd::cout &lt;&lt; message &lt;&lt; std::endl;\n\nif (Logging::get().error_level &lt;= Flint::LogLevel::ERROR)\nthrow_exception(Flint::TooHighLevelLoggingError, message);\n}\n\nvoid Logging::critical(\nconst std::string&amp; message,\nstd::optional&lt;std::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;&gt;\npositional_infos)\n{\nstd::cout &lt;&lt; \"[ \" &lt;&lt; Flint::Colors::B_RED &lt;&lt; \"CRIT\"\n&lt;&lt; Flint::Colors::RESET &lt;&lt; \" ] \";\n\nif (positional_infos)\nLogging::display_positional_infos(*positional_infos);\n\nstd::cout &lt;&lt; message &lt;&lt; std::endl;\n\nif (Logging::get().error_level &lt;= Flint::LogLevel::CRITICAL)\nthrow_exception(Flint::TooHighLevelLoggingError, message);\n}\n}\n</code></pre>"},{"location":"coverage/backend/flint/src/Logging/Logging.hpp/","title":"Logging.hpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#ifndef INCLUDED_LOGGING_HPP\n#define INCLUDED_LOGGING_HPP\n\n#include \"../Colors/Colors.hpp\"\n#include \"../CxxABI/CxxABI.hpp\"\n#include \"../Exceptions/Exceptions.hpp\"\n#include \"../Headers.hpp\"\n\n#include &lt;optional&gt;\n\nnamespace Flint\n{\nenum LogLevel {\nDEBUG    = 0,\nINFO     = 1,\nWARNING  = 2,\nERROR    = 3,\nCRITICAL = 4,\nNONE     = 5,\n};\n\nclass TooHighLevelLoggingError: public Flint::Exceptions::Exception\n{\npublic:\nTooHighLevelLoggingError(\nconst std::string&amp; what =\n\"The message logged is of criticly high level.\",\nstd::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;\ninfos = {{\"\", 0}, \"\"}):\nException(what, infos)\n{\n}\n};\n\nclass Logging\n{\nprivate:\nLogging() {}\n\nbool     log_on_stderr = false;\nLogLevel display_level = LogLevel::INFO;\nLogLevel error_level   = LogLevel::CRITICAL;\n\nstatic Logging&amp; get();\n\npublic:\nLogging(const Logging&amp;)        = delete;\nvoid operator=(const Logging&amp;) = delete;\n\nstatic void set_log_on_stderr(bool log_on_stderr);\nstatic void set_log_level(LogLevel level);\nstatic void set_error_level(LogLevel level);\n\nstatic void display_positional_infos(\nstd::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;\npositional_infos);\n\nstatic void\ndebug(const std::string&amp;                    message,\nstd::optional&lt;std::pair&lt;std::pair&lt;std::string, std::size_t&gt;,\nstd::string&gt;&gt; positional_infos =\nstd::nullopt);\n\nstatic void\ninfo(const std::string&amp;                    message,\nstd::optional&lt;std::pair&lt;std::pair&lt;std::string, std::size_t&gt;,\nstd::string&gt;&gt; positional_infos =\nstd::nullopt);\n\nstatic void warning(\nconst std::string&amp; message,\nstd::optional&lt;\nstd::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;&gt;\npositional_infos = std::nullopt);\n\nstatic void\nerror(const std::string&amp;                    message,\nstd::optional&lt;std::pair&lt;std::pair&lt;std::string, std::size_t&gt;,\nstd::string&gt;&gt; positional_infos =\nstd::nullopt);\n\nstatic void critical(\nconst std::string&amp; message,\nstd::optional&lt;\nstd::pair&lt;std::pair&lt;std::string, std::size_t&gt;, std::string&gt;&gt;\npositional_infos = std::nullopt);\n};\n}\n\n#endif\n</code></pre>"},{"location":"coverage/backend/flint/src/hpp/","title":"hpp","text":"Name Lines Covered Uncovered Coverage Inspection.hpp 7 0 7 0.0% Preprocessor.hpp 0 0 0 100.0% Summary 7 0 7 0.0%"},{"location":"coverage/backend/flint/src/hpp/Inspection.hpp/","title":"Inspection.hpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#ifndef INCLUDED_INSPECTION_HPP\n#define INCLUDED_INSPECTION_HPP\n\n#include \"../CxxABI/CxxABI.hpp\"\n#include \"../Headers.hpp\"\n\nnamespace Flint\n{\n/**\n     * Base class to implement simplet self-reflexion in C++\n     *\n     * @ingroup flint\n     *\n     * @tparam T Child class itself\n     *\n     * @tip\n     * When creating a child class, define as follow :\n     * ```cpp\n     * class ChildClass: public Inspection&lt;ChildClass&gt;\n     * ```\n     * This will extand the ChildClass with the self-reflexion class Inspection\n     *\n     * @warning\n     * If the class you want to extand as a reflected class will be a parent\n     * class (I.E. You will create childs of this \"target\" class), you might\n     * want to mark inheritence as **virtual**. This is needed if your child\n     * class _also_ need to be reflected. This way, there is no confilict\n     * between the parent reflexion, and the child reflexion.\n     */\ntemplate&lt;typename T&gt;\nclass Inspection\n{\npublic:\n/**\n             * Return the name of the reflected class\n             *\n             * @return The demangled name of the class, or just the name, if\n             * demangleing failed\n             */\nvirtual std::string getClassName() const final\n{\nreturn CxxABI::demangle(typeid(T).name());\n}\n\n// virtual std::unordered_set&lt;std::pair&lt;std::string, std::string&gt;&gt;\n// getAttributes();\n\n/**\n             * Return a string representation of the class\n             *\n             * @tip\n             * This function is not intended to be used.\n             * This is because this functions display the reflection.\n             * You might prefer to override this function in yout child\n             * class to display informations that are more relevant to\n             * your specific class.\n             *\n             * @example\n             * You have a Macro available to make the str function really\n             * easilly :\n             * ```cpp\n             * display_attr(attribute)\n             * ```\n             * Which will automaticly translate to\n             * ```cpp\n             * Flint::Colors::F_BLUE &lt;&lt; \"attribute\" &lt;&lt; Flint::Colors::RESET &lt;&lt;\n             * \"=\" &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute &lt;&lt;\n             * Flint::Colors::RESET\n             * ```\n             * There is also a `make_str` macro, which you can use as follow :\n             * ```cpp\n             * return make_str(\"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\");\n             * ```\n             * that becomes\n             * ```cpp\n             * return ({std::stringstream ss; ss &lt;&lt; \"&lt;\" &lt;&lt; this-&gt;getClassName()\n             * &lt;&lt; \" at \" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; \": \" &lt;&lt; \"a=12\" &lt;&lt; \", \" &lt;&lt; \"b=5\"\n             * &lt;&lt; \"&gt;\"; ss.str()})\n             * ```\n             * It means you can define the str function of your class as like\n             * that :\n             * ```cpp\n             * // Provided you have 3 attributes called a, b and c\n             * return make_str(display_attr(a) &lt;&lt; \", \" &lt;&lt; display_attr(b) &lt;&lt; \",\n             * \" &lt;&lt; display_attr(c));\n             * ```\n             *\n             * @return The string representation of the class\n             */\nvirtual std::string str() const\n{\nstd::stringstream ss;\n\nss &lt;&lt; \"&lt;\" &lt;&lt; Flint::Colors::F_PURPLE &lt;&lt; this-&gt;getClassName()\n&lt;&lt; Flint::Colors::RESET &lt;&lt; \" at \" &lt;&lt; Flint::Colors::YELLOW\n&lt;&lt; std::hex &lt;&lt; this &lt;&lt; Flint::Colors::RESET &lt;&lt; \"&gt;\";\n\nreturn ss.str();\n}\n\n/** Overload the operator &lt;&lt; to use the str method of the object\n             *\n             * @tparam T Reflected class\n             *\n             * @param os Reference of ostream (I.E. std::cout, std::cerr...)\n             *\n             * @param obj Object reference to be displayed\n             *\n             * @return Param os\n             */\nfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;        os,\nconst Inspection&lt;T&gt;&amp; obj)\n{\nos &lt;&lt; obj.str();\nreturn os;\n}\n};\n}\n\n\n#endif\n</code></pre>"},{"location":"coverage/backend/flint/src/hpp/Preprocessor.hpp/","title":"Preprocessor.hpp","text":"<pre><code>/**************\n *\n *      @\n *       @\n *     @@@\n *\n **************/\n\n\n#ifndef INCLUDED_PREPROCESSOR_HPP\n#define INCLUDED_PREPROCESSOR_HPP\n\n#if defined(__GNUC__)\n#define __FUNCTION__ __PRETTY_FUNCTION__\n#elif defined(_MSC_VER)\n#define __FUNCTION__ __FUNCSIG__\n#else\n#define __FUNCTION__ __func__\n#endif\n\n#define __POSITION_INFOS__                                                    \\\n    std::pair                                                                 \\\n    {                                                                         \\\n        std::pair{std::string(__FILE__), __LINE__}, std::string(__FUNCTION__) \\\n    }\n\n#define throw_exception(exception, message)       \\\n    throw(exception(message, __POSITION_INFOS__))\n#define catch_exception(exception) exception.show(__POSITION_INFOS__)\n\n// Inspection\n#define display_attr(attribute)                                        \\\n    Flint::Colors::F_BLUE &lt;&lt; #attribute &lt;&lt; Flint::Colors::RESET &lt;&lt; \"=\" \\\n                          &lt;&lt; Flint::Colors::RED &lt;&lt; this-&gt;attribute     \\\n                          &lt;&lt; Flint::Colors::RESET\n#define make_str(display)                                            \\\n    ({                                                               \\\n        std::stringstream ss;                                        \\\n        ss &lt;&lt; Flint::Colors::RESET &lt;&lt; \"&lt;\" &lt;&lt; Flint::Colors::F_PURPLE \\\n           &lt;&lt; this-&gt;getClassName() &lt;&lt; Flint::Colors::RESET &lt;&lt; \" at \" \\\n           &lt;&lt; Flint::Colors::YELLOW &lt;&lt; std::hex &lt;&lt; this &lt;&lt; std::dec  \\\n           &lt;&lt; Flint::Colors::RESET &lt;&lt; \": \" &lt;&lt; display &lt;&lt; \"&gt;\";        \\\n        ss.str();                                                    \\\n    })\n\n#define log_debug(message)                                                 \\\n    Flint::Logging::debug(message, std::make_optional(__POSITION_INFOS__))\n#define log_info(message)  Flint::Logging::info(message, std::make_optional(__POSITION_INFOS__))\n#define log_warn(message)  Flint::Logging::warning(message, std::make_optional(__POSITION_INFOS__))\n#define log_error(message) Flint::Logging::error(message, std::make_optional(__POSITION_INFOS__))\n#define log_critical(message)                             \\\n    Flint::Logging::critical(message, std::make_optional(__POSITION_INFOS__))\n\n#endif\n</code></pre>"},{"location":"coverage/backend/src/","title":"src","text":"Name Lines Covered Uncovered Coverage PluginSystem 108 0 108 0.0% Protocol 1 0 1 0.0% AProtocol.hpp 1 0 1 0.0% Tool 1 0 1 0.0% ATool.hpp 1 0 1 0.0% IPlugin.hpp 0 0 0 100.0% PluginHotloader.cpp 44 0 44 0.0% PluginHotloader.hpp 0 0 0 100.0% PluginLoader.cpp 62 0 62 0.0% PluginLoader.hpp 0 0 0 100.0% main.cpp 10 0 10 0.0% Summary 1 0 1 0.0% Summary 1 0 1 0.0% Summary 108 0 108 0.0% Summary 118 0 118 0.0%"},{"location":"coverage/backend/src/main.cpp/","title":"main.cpp","text":"<pre><code>#include \"PluginSystem/PluginLoader.hpp\"\n#include \"PluginSystem/PluginHotloader.hpp\"\n#include &lt;csignal&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n\nstatic volatile std::sig_atomic_t g_stopRequested = 0;\nextern \"C\" void handle_signal(int) { g_stopRequested = 1; }\n\nint main() {\nstd::signal(SIGINT, handle_signal);\nstd::signal(SIGTERM, handle_signal);\n\nstd::vector&lt;PluginSystem::ATool*&gt; tools;\nstd::vector&lt;PluginSystem::AProtocol*&gt; protocols;\n\nPluginSystem::PluginLoader loader(tools, protocols);\nloader.loadAllPlugins(\"Plugins\");\n\nPluginSystem::PluginHotloader hotloader(\"Plugins\", loader);\nhotloader.start();\n\nstd::cout &lt;&lt; \"[Main] Press Ctrl+C to stop...\" &lt;&lt; std::endl;\nwhile (!g_stopRequested)\nstd::this_thread::sleep_for(std::chrono::milliseconds(250));\n\nhotloader.stop();\nreturn 0;\n}\n</code></pre>"},{"location":"coverage/backend/src/PluginSystem/","title":"PluginSystem","text":"Name Lines Covered Uncovered Coverage Protocol 1 0 1 0.0% AProtocol.hpp 1 0 1 0.0% Tool 1 0 1 0.0% ATool.hpp 1 0 1 0.0% IPlugin.hpp 0 0 0 100.0% PluginHotloader.cpp 44 0 44 0.0% PluginHotloader.hpp 0 0 0 100.0% PluginLoader.cpp 62 0 62 0.0% PluginLoader.hpp 0 0 0 100.0% Summary 1 0 1 0.0% Summary 1 0 1 0.0% Summary 108 0 108 0.0%"},{"location":"coverage/backend/src/PluginSystem/IPlugin.hpp/","title":"IPlugin.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2025\n** tek4\n** File description:\n** IPlugin\n*/\n\n#ifndef IPLUGIN_HPP_\n#define IPLUGIN_HPP_\n\nnamespace PluginSystem {\nenum class PluginType {\nTOOL,\nPROTOCOL\n};\nclass IPlugin {\npublic:\nvirtual ~IPlugin() = default;\n\nvirtual PluginType getType() const = 0;\nvirtual void toggle() = 0;\n};\n}\n\n#endif /* !IPLUGIN_HPP_ */\n</code></pre>"},{"location":"coverage/backend/src/PluginSystem/PluginHotloader.cpp/","title":"PluginHotloader.cpp","text":"<pre><code>#include \"PluginHotloader.hpp\"\n#include &lt;sys/inotify.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n\nusing namespace PluginSystem;\n\nPluginHotloader::PluginHotloader(const std::string &amp;path, PluginLoader &amp;loaderRef)\n: pluginsDir(path), loader(loaderRef) {}\n\nPluginHotloader::~PluginHotloader() {\nstop();\n}\n\nvoid PluginHotloader::start() {\nif (running) return;\nrunning = true;\nwatcherThread = std::thread(&amp;PluginHotloader::watchLoop, this);\n}\n\nvoid PluginHotloader::stop() {\nif (!running) return;\nrunning = false;\n\nif (inotifyFd &gt;= 0) {\ninotify_rm_watch(inotifyFd, watchDescriptor);\nclose(inotifyFd);\ninotifyFd = -1;\n}\n\nif (watcherThread.joinable())\nwatcherThread.join();\n}\n\nvoid PluginHotloader::watchLoop() {\ninotifyFd = inotify_init1(IN_NONBLOCK);\nif (inotifyFd &lt; 0) {\nstd::cerr &lt;&lt; \"[Hotloader] Failed to initialize inotify.\" &lt;&lt; std::endl;\nreturn;\n}\n\nwatchDescriptor = inotify_add_watch(inotifyFd, pluginsDir.c_str(),\nIN_CREATE | IN_MODIFY | IN_DELETE | IN_MOVED_TO | IN_MOVED_FROM);\n\nif (watchDescriptor &lt; 0) {\nstd::cerr &lt;&lt; \"[Hotloader] Failed to add inotify watch on \" &lt;&lt; pluginsDir &lt;&lt; std::endl;\nclose(inotifyFd);\nreturn;\n}\n\nstd::cout &lt;&lt; \"[Hotloader] Watching directory: \" &lt;&lt; pluginsDir &lt;&lt; std::endl;\n\nconst size_t eventSize = sizeof(struct inotify_event);\nconst size_t bufLen = 1024 * (eventSize + 16);\nchar buffer[bufLen];\n\nwhile (running) {\nint length = read(inotifyFd, buffer, bufLen);\nif (length &lt; 0) {\nif (errno == EAGAIN) {\nstd::this_thread::sleep_for(std::chrono::milliseconds(100));\ncontinue;\n}\nbreak;\n}\n\nint i = 0;\nwhile (i &lt; length) {\nstruct inotify_event* event = (struct inotify_event*)&amp;buffer[i];\nif (event-&gt;len &gt; 0) {\nstd::string filename = event-&gt;name;\nstd::string filepath = pluginsDir + \"/\" + filename;\n\nif (filename.size() &gt; 3 &amp;&amp; filename.substr(filename.size() - 3) == \".so\") {\nif (event-&gt;mask &amp; (IN_CREATE | IN_MOVED_TO | IN_MODIFY)) {\nstd::cout &lt;&lt; \"[Hotloader] Reloading: \" &lt;&lt; filename &lt;&lt; std::endl;\nloader.unloadPlugin(filename);\nloader.loadPlugin(filepath);\n} else if (event-&gt;mask &amp; (IN_DELETE | IN_MOVED_FROM)) {\nstd::cout &lt;&lt; \"[Hotloader] Removing: \" &lt;&lt; filename &lt;&lt; std::endl;\nloader.unloadPlugin(filename);\n}\n}\n}\ni += eventSize + event-&gt;len;\n}\n}\n\nstd::cout &lt;&lt; \"[Hotloader] Stopped watching.\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"coverage/backend/src/PluginSystem/PluginHotloader.hpp/","title":"PluginHotloader.hpp","text":"<pre><code>#ifndef PLUGIN_HOTLOADER_HPP_\n#define PLUGIN_HOTLOADER_HPP_\n\n#include \"PluginLoader.hpp\"\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;atomic&gt;\n#include &lt;vector&gt;\n\nnamespace PluginSystem {\nclass PluginHotloader {\npublic:\nPluginHotloader(const std::string &amp;path,\nPluginLoader &amp;loader);\n~PluginHotloader();\n\nvoid start();\nvoid stop();\n\nprivate:\nvoid watchLoop();\n\nstd::string pluginsDir;\nPluginLoader &amp;loader;\nstd::thread watcherThread;\nstd::atomic&lt;bool&gt; running{false};\nint inotifyFd = -1;\nint watchDescriptor = -1;\n};\n}\n\n#endif /* !PLUGIN_HOTLOADER_HPP_ */\n</code></pre>"},{"location":"coverage/backend/src/PluginSystem/PluginLoader.cpp/","title":"PluginLoader.cpp","text":"<pre><code>#include \"PluginLoader.hpp\"\n#include &lt;algorithm&gt;\n\nusing namespace PluginSystem;\n\nPluginLoader::PluginLoader(std::vector&lt;ATool*&gt;&amp; tools, std::vector&lt;AProtocol*&gt;&amp; protocols)\n: toolList(tools), protocolList(protocols) {\nstd::cout &lt;&lt; \"[PluginLoader] Initialized.\" &lt;&lt; std::endl;\n}\n\nPluginLoader::~PluginLoader() {\nunloadAllPlugins();\nstd::cout &lt;&lt; \"[PluginLoader] All plugins unloaded.\" &lt;&lt; std::endl;\n}\n\nvoid PluginLoader::loadAllPlugins(const std::string&amp; pluginsDirectory) {\nif (!fs::exists(pluginsDirectory) || !fs::is_directory(pluginsDirectory)) {\nstd::cerr &lt;&lt; \"[Loader] Directory not found: \" &lt;&lt; pluginsDirectory &lt;&lt; std::endl;\nreturn;\n}\n\nfor (auto&amp; entry : fs::directory_iterator(pluginsDirectory)) {\nif (entry.is_regular_file() &amp;&amp; entry.path().extension() == \".so\")\nloadPlugin(entry.path().string());\n}\n\nstd::cout &lt;&lt; \"[Loader] Loaded \" &lt;&lt; toolList.size() &lt;&lt; \" tool(s) and \"\n&lt;&lt; protocolList.size() &lt;&lt; \" protocol(s).\" &lt;&lt; std::endl;\n}\n\nbool PluginLoader::loadPlugin(const std::string&amp; path) {\nstd::string filename = fs::path(path).filename().string();\n\nvoid* handle = dlopen(path.c_str(), RTLD_LAZY);\nif (!handle) {\nstd::cerr &lt;&lt; \"[Loader] Failed to open plugin (\" &lt;&lt; path &lt;&lt; \"): \" &lt;&lt; dlerror() &lt;&lt; std::endl;\nreturn false;\n}\n\ndlerror();\nusing CreateInstanceFn = IPlugin* (*)();\nCreateInstanceFn instance = reinterpret_cast&lt;CreateInstanceFn&gt;(dlsym(handle, \"instance\"));\nconst char* error = dlerror();\nif (error) {\nstd::cerr &lt;&lt; \"[Loader] Missing factory symbol in \" &lt;&lt; path &lt;&lt; \": \" &lt;&lt; error &lt;&lt; std::endl;\ndlclose(handle);\nreturn false;\n}\n\nIPlugin* plugin = instance();\nif (!plugin) {\nstd::cerr &lt;&lt; \"[Loader] Failed to create plugin instance: \" &lt;&lt; path &lt;&lt; std::endl;\ndlclose(handle);\nreturn false;\n}\n\nif (plugin-&gt;getType() == PluginType::TOOL) {\nauto* tool = dynamic_cast&lt;ATool*&gt;(plugin);\nif (tool) {\ntoolList.push_back(tool);\nstd::cout &lt;&lt; \"[Loader] Loaded Tool: \" &lt;&lt; filename &lt;&lt; std::endl;\n}\n} else if (plugin-&gt;getType() == PluginType::PROTOCOL) {\nauto* proto = dynamic_cast&lt;AProtocol*&gt;(plugin);\nif (proto) {\nprotocolList.push_back(proto);\nstd::cout &lt;&lt; \"[Loader] Loaded Protocol: \" &lt;&lt; filename &lt;&lt; std::endl;\n}\n}\n\npluginHandles[filename] = handle;\npluginInstances[filename] = plugin;\nreturn true;\n}\n\nbool PluginLoader::unloadPlugin(const std::string&amp; filename) {\nauto itHandle = pluginHandles.find(filename);\nauto itInstance = pluginInstances.find(filename);\nif (itHandle == pluginHandles.end() || itInstance == pluginInstances.end())\nreturn false;\n\nIPlugin* plugin = itInstance-&gt;second;\nauto type = plugin-&gt;getType();\n\nif (type == PluginType::TOOL)\ntoolList.erase(std::remove(toolList.begin(), toolList.end(), plugin), toolList.end());\nelse if (type == PluginType::PROTOCOL)\nprotocolList.erase(std::remove(protocolList.begin(), protocolList.end(), plugin), protocolList.end());\n\ndelete plugin;\ndlclose(itHandle-&gt;second);\n\npluginHandles.erase(itHandle);\npluginInstances.erase(itInstance);\n\nstd::cout &lt;&lt; \"[Loader] Unloaded: \" &lt;&lt; filename &lt;&lt; std::endl;\nreturn true;\n}\n\nvoid PluginLoader::unloadAllPlugins() {\nstd::vector&lt;std::string&gt; filenames;\nfilenames.reserve(pluginInstances.size());\n\nfor (const auto&amp; [filename, _] : pluginInstances)\nfilenames.push_back(filename);\n\nfor (const auto&amp; filename : filenames)\nunloadPlugin(filename);\n\npluginHandles.clear();\npluginInstances.clear();\n}\n</code></pre>"},{"location":"coverage/backend/src/PluginSystem/PluginLoader.hpp/","title":"PluginLoader.hpp","text":"<pre><code>#ifndef PLUGINLOADER_HPP_\n#define PLUGINLOADER_HPP_\n\n#include \"IPlugin.hpp\"\n#include \"Tool/ATool.hpp\"\n#include \"Protocol/AProtocol.hpp\"\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\n#include &lt;dlfcn.h&gt;\n#include &lt;unordered_map&gt;\n\nnamespace fs = std::filesystem;\n\nnamespace PluginSystem {\nclass PluginLoader {\npublic:\nPluginLoader(std::vector&lt;ATool*&gt;&amp; tools, std::vector&lt;AProtocol*&gt;&amp; protocols);\n~PluginLoader();\n\nvoid loadAllPlugins(const std::string&amp; pluginsDirectory);\nbool loadPlugin(const std::string&amp; path);\nbool unloadPlugin(const std::string&amp; filename);\nvoid unloadAllPlugins();\n\nprivate:\nstd::vector&lt;ATool*&gt;&amp; toolList;\nstd::vector&lt;AProtocol*&gt;&amp; protocolList;\nstd::unordered_map&lt;std::string, void*&gt; pluginHandles;\nstd::unordered_map&lt;std::string, IPlugin*&gt; pluginInstances;\n};\n}\n\n#endif /* !PLUGINLOADER_HPP_ */\n</code></pre>"},{"location":"coverage/backend/src/PluginSystem/Protocol/","title":"Protocol","text":"Name Lines Covered Uncovered Coverage AProtocol.hpp 1 0 1 0.0% Summary 1 0 1 0.0%"},{"location":"coverage/backend/src/PluginSystem/Protocol/AProtocol.hpp/","title":"AProtocol.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2025\n** tek4\n** File description:\n** AProtocol\n*/\n\n#ifndef APROTOCOL_HPP_\n#define APROTOCOL_HPP_\n\n#include \"../IPlugin.hpp\"\n\nnamespace PluginSystem {\nclass AProtocol : public IPlugin {\npublic:\nvirtual ~AProtocol() = default;\n\n//* Plugin Related Methods *//\nPluginType getType() const override {\nreturn PluginType::PROTOCOL;\n}\nvirtual void toggle() override = 0;\n\n//* Protocol Specific Methods *//\nvirtual void connect() = 0;\nvirtual void disconnect() = 0;\nvirtual bool isConnected() const = 0;\n};\n}\n\n#endif /* !APROTOCOL_HPP_ */\n</code></pre>"},{"location":"coverage/backend/src/PluginSystem/Tool/","title":"Tool","text":"Name Lines Covered Uncovered Coverage ATool.hpp 1 0 1 0.0% Summary 1 0 1 0.0%"},{"location":"coverage/backend/src/PluginSystem/Tool/ATool.hpp/","title":"ATool.hpp","text":"<pre><code>/*\n** EPITECH PROJECT, 2025\n** tek4\n** File description:\n** ATool\n*/\n\n#ifndef ATOOL_HPP_\n#define ATOOL_HPP_\n\n#include \"../IPlugin.hpp\"\n\nnamespace PluginSystem {\nclass ATool : public IPlugin {\npublic:\nvirtual ~ATool() = default;\n\n//* Plugin Related Methods *//\nPluginType getType() const override {\nreturn PluginType::TOOL;\n}\nvirtual void toggle() override = 0;\n\n//* Tool Specific Methods *//\nvirtual void execute() = 0;\n};\n}\n\n#endif /* !ATOOL_HPP_ */\n</code></pre>"}]}